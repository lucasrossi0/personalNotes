[
  {
    "objectID": "spring-boot/controller-layer.html",
    "href": "spring-boot/controller-layer.html",
    "title": "Controller Layer",
    "section": "",
    "text": "What is it?\naaaa\n\n\nHow to implement?\nThe differences in the implementation is that the Service should only be responsible for the bussiness logic and nothing else. And the Controller should be responsible for mapping the Http response and manage exceptions of them.\nExample of a bad usage of the Controller layer\n\npackage dev.pronunciationAppBack.controller;\n\nimport dev.pronunciationAppBack.model.User;\nimport dev.pronunciationAppBack.repository.UserRepository;\nimport dev.pronunciationAppBack.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers(){\n        return userService.getAllUsers();\n    }\n\n    @PostMapping(\"/isActive\")\n    public ResponseEntity&lt;String&gt; isUserActive(@RequestBody User user){\n        return userService.isUserActive(user);\n    }\n\n    @PostMapping(\"/createUser\")\n    public ResponseEntity&lt;?&gt; createUser(@RequestBody User user){\n        return userService.createUser(user);\n    }\n\n    @DeleteMapping()\n    public void deleteAllWords(){\n        userService.deleteAllWords();\n    }\n\n/*    @DeleteMapping()\n    public void deleteUser(@RequestBody User user){\n        userService.deleteUser(user);\n    }*/\n\n    @DeleteMapping(\"/{id}\")\n    public void deleteUserById(@RequestParam String id){\n        userService.getUserById(id);\n    }\n\n\n}\nCorrect usage of the Service layer\npackage dev.pronunciationAppBack.controller;\n\nimport dev.pronunciationAppBack.model.User;\nimport dev.pronunciationAppBack.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.Date;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/active\")\n    public ResponseEntity&lt;String&gt; isUserActive(@RequestBody User user) {\n        HttpHeaders headers = getCommonHeaders(\"Check if user is active\");\n        return userService.isUserActive(user)\n                ? new ResponseEntity&lt;&gt;(\"User is active\", headers, HttpStatus.OK)\n                : new ResponseEntity&lt;&gt;(\"User not active\", headers, HttpStatus.NO_CONTENT);\n    }\n\n    @GetMapping\n    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() {\n        List&lt;User&gt; users = userService.getAllUsers();\n        HttpHeaders headers = getCommonHeaders(\"Get all users\");\n        return users.isEmpty()\n                ? new ResponseEntity&lt;&gt;(headers, HttpStatus.NOT_FOUND)\n                : new ResponseEntity&lt;&gt;(users, headers, HttpStatus.OK);\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;?&gt; getUserById(@PathVariable String id) {\n        HttpHeaders headers = getCommonHeaders(\"Get user by ID\");\n        return userService.getUserById(id)\n                .map(user -&gt; new ResponseEntity&lt;&gt;(user, headers, HttpStatus.OK))\n                .orElse(new ResponseEntity&lt;&gt;(headers, HttpStatus.NOT_FOUND));\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {\n        User createdUser = userService.createUser(user);\n        HttpHeaders headers = getCommonHeaders(\"Create a new user\");\n        return new ResponseEntity&lt;&gt;(createdUser, headers, HttpStatus.CREATED);\n    }\n\n    @PutMapping\n    public ResponseEntity&lt;User&gt; updateUser(@RequestBody User user) {\n        HttpHeaders headers = getCommonHeaders(\"Update a user\");\n        return userService.updateUser(user)\n                .map(updatedUser -&gt; new ResponseEntity&lt;&gt;(updatedUser, headers, HttpStatus.OK))\n                .orElse(new ResponseEntity&lt;&gt;(headers, HttpStatus.NOT_FOUND));\n    }\n\n    @DeleteMapping\n    public ResponseEntity&lt;Void&gt; deleteAllUsers() {\n        userService.deleteAllUsers();\n        HttpHeaders headers = getCommonHeaders(\"Delete all users\");\n        return new ResponseEntity&lt;&gt;(headers, HttpStatus.OK);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity&lt;Void&gt; deleteById(@PathVariable String id) {\n        HttpHeaders headers = getCommonHeaders(\"Delete user by ID\");\n        return userService.deleteById(id)\n                ? new ResponseEntity&lt;&gt;(headers, HttpStatus.OK)\n                : new ResponseEntity&lt;&gt;(headers, HttpStatus.NOT_FOUND);\n    }\n\n    @DeleteMapping(\"/user\")\n    public ResponseEntity&lt;Void&gt; deleteUser(@RequestBody User user) {\n        HttpHeaders headers = getCommonHeaders(\"Delete specific user\");\n        return userService.deleteUser(user)\n                ? new ResponseEntity&lt;&gt;(headers, HttpStatus.OK)\n                : new ResponseEntity&lt;&gt;(headers, HttpStatus.NOT_FOUND);\n    }\n\n    @GetMapping(\"/{id}/level\")\n    public ResponseEntity&lt;Integer&gt; getUserLevel(@PathVariable String id) {\n        HttpHeaders headers = getCommonHeaders(\"Get user level\");\n        return userService.getUserLevel(id)\n                .map(level -&gt; new ResponseEntity&lt;&gt;(level, headers, HttpStatus.OK))\n                .orElse(new ResponseEntity&lt;&gt;(headers, HttpStatus.NOT_FOUND));\n    }\n\n    private HttpHeaders getCommonHeaders(String description) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"desc\", description);\n        headers.add(\"content-type\", \"application/json\");\n        headers.add(\"date\", new Date().toString());\n        headers.add(\"server\", \"Spring Boot\");\n        headers.add(\"version\", \"1.0.0\");\n        headers.add(\"user-count\", String.valueOf(userService.getUserCount()));\n        headers.add(\"object\", \"users\");\n        return headers;\n    }\n}"
  },
  {
    "objectID": "template.html",
    "href": "template.html",
    "title": "Title",
    "section": "",
    "text": "Section 1\nText…"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "My documentation\n\nJunior Java developer. Slowly but steady learning more about Spring framework. In a future being a fullstack with react."
  },
  {
    "objectID": "java-concepts/java-concepts-stream.html",
    "href": "java-concepts/java-concepts-stream.html",
    "title": "Java Concepts - Stream",
    "section": "",
    "text": "Basics of stream\n\nStream is an interface, which can process elements inside a data structure in a way more functional.   But more functional? How? - Being able to read and understand better; - Writes less lines of code; - Combine mutiple operations in a single chain.   Speaking on a more technichal manner, we can use operations like filter(), map(), collect(), to obtain the same result as a for each loop with conditionals inside it. Example: \n// Not using stream. Using while loop.\npublic int totalWeight() {\n    int summa = 0;\n    int indeksi = 0;\n    while (indeksi &lt; this.Items.size()) {\n        summa += this.Items.get(indeksi).getWeight();\n        indeksi++;\n    }\n    return summa;\n}\n    \n// Using stream -&gt; mapToInt is to return the a stream of int with \n// all the weight of the obj inside the Items, and return the sum() of all.\npublic int totalWeight(){\n    return Items.stream().mapToInt(obj -&gt; obj.getWeight()).sum();\n}"
  },
  {
    "objectID": "programming-concepts/dependecy-injection.html",
    "href": "programming-concepts/dependecy-injection.html",
    "title": "Dependency Injection",
    "section": "",
    "text": "In simple words is injecting a object or an element into another class to being able to use its functions and atributes or dependencies.   In java is being able to utilize anothers class or interface methods and atributes in another class where you want to utilize it, instead of creating and instanciating a new object, its easier to just inject it. There are three types of dependecy injection Conctructor injection, Setter injection and Method injection. Here its and example in Spring:\n// Constructor injection:\n@Service\npublic class BookService {\n    // Or just the atribute with @Autowired, spring takes care to manage its lifecycle\n    @Autowired\n    private final BookRepository bookRepository;\n    \n    @Autowired\n    public BookService(BookRepository bookRepository) {\n        this.bookRepository = bookRepository;\n    }\n}\n\n// Setter injection\n@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n\n// Method injection\n@Service\npublic class OrderService {\n    private OrderRepository orderRepository;\n    private PaymentService paymentService;\n    \n    @Autowired\n    public void init(OrderRepository orderRepository, PaymentService paymentService) {\n        this.orderRepository = orderRepository;\n        this.paymentService = paymentService;\n    }\n}\n\n\n\nThis is often done using frameworks like Spring Boot, where dependencies are defined as beans and injected into other beans using annotations."
  },
  {
    "objectID": "programming-concepts/dependecy-injection.html#words-from-albert-profe",
    "href": "programming-concepts/dependecy-injection.html#words-from-albert-profe",
    "title": "Dependency Injection",
    "section": "",
    "text": "This is often done using frameworks like Spring Boot, where dependencies are defined as beans and injected into other beans using annotations."
  },
  {
    "objectID": "java-concepts/java-concepts-test.html",
    "href": "java-concepts/java-concepts-test.html",
    "title": "Java Concepts - Test",
    "section": "",
    "text": "Why we need to test?\nIn software development testing is important for a lot of reasons, a few of them being:   Verifying the functionality of the application, or a specific method or function; Detecting bugs or errors, its better and cheaper to find them in development rather than production; Improve code quality, ensuring that the output of the application is what its expected to be.\n\n\nHow we test?\nThere are plenty of tools to test, in Java we will talk about (JUnit)[https://junit.org/junit5/] and (Mockito)[https://site.mockito.org/].  Here is a code snippet of JUnit and Mockito:\npackage dev.pronunciationAppBack;\n\nimport dev.pronunciationAppBack.model.Word;\nimport dev.pronunciationAppBack.repository.WordRepository;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\nimport org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@DataJpaTest\npublic class PronunciationAppBackApplicationTests {\n\n    @Autowired\n    private TestEntityManager entityManager;\n\n    @Autowired\n    private WordRepository wordRepository;\n\n    @Test\n    public void testCreateWord() {\n        Word word = new Word(\"1\", \"Example\", \"A thing characteristic of its kind\", \"ɪɡˈzæmpəl\", \"This is an example sentence.\", true, 1);\n        // assign the word object to the repository and save to H2\n        Word savedWord = wordRepository.save(word);\n        assertThat(savedWord).isNotNull();\n        assertThat(savedWord.getId()).isEqualTo(\"1\");\n    }\n}\n\n// Mockito:\n\npackage dev.pronunciationAppBack;\n\nimport dev.pronunciationAppBack.model.Word;\nimport dev.pronunciationAppBack.repository.WordRepository;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport java.util.Optional;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class PronunciationAppBackApplicationTests {\n\n    @Mock\n    private WordRepository wordRepository;\n\n    private Word testWord;\n\n    @BeforeEach\n    void setUp() {\n        testWord = new Word(\"1\", \"Example\", \"A thing characteristic of its kind\", \n            \"ɪɡˈzæmpəl\", \"This is an example sentence.\", true, 1);\n    }\n\n    @Test\n    public void testCreateWord() {\n        when(wordRepository.save(any(Word.class))).thenReturn(testWord);\n\n        Word savedWord = wordRepository.save(testWord);\n\n        assertThat(savedWord).isNotNull();\n        assertThat(savedWord.getId()).isEqualTo(\"1\");\n        verify(wordRepository, times(1)).save(any(Word.class));\n    }\n}"
  },
  {
    "objectID": "java-concepts/java-concepts-optional.html",
    "href": "java-concepts/java-concepts-optional.html",
    "title": "Java Concepts - Optional",
    "section": "",
    "text": "What is optional?\n\nOptional is a Java Class, created to handle a value that can or cannot be present. In other words, if the value is assigned to something or is empty or null.  For example, if an object being returned is empty, the application will stop with an NullPointerException. When implemented, the Option class will prevent that error and return an explicty call to empty.   Heres a code snippet:\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Word&gt; getWordById(@PathVariable String id){\n        // Creating the word object using optional to avoid the NullPointerException\n        Optional&lt;Word&gt; word = wordService.getWordById(id);\n        // Mapping the potential return case if the word is found or not\n        return word.map(value -&gt; new ResponseEntity&lt;&gt;(value, HttpStatus.OK))\n        .orElseGet(() -&gt; new ResponseEntity&gt;(HttpStatus.NOT_FOUND));\n    }"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "spring-boot/service-layer.html",
    "href": "spring-boot/service-layer.html",
    "title": "Service Layer",
    "section": "",
    "text": "What is it?\naaaa\n\n\nHow to implement?\nThe differences in the implementation is that the Service should only be responsible for the bussiness logic and nothing else. And the Controller should be responsible for mapping the Http response and manage exceptions of them.\nExample of a bad usage of the Service layer\n\npackage dev.pronunciationAppBack.service;\n\nimport com.sun.net.httpserver.HttpsServer;\nimport dev.pronunciationAppBack.model.User;\nimport dev.pronunciationAppBack.repository.UserRepository;\nimport org.apache.coyote.Response;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    // Method returns the state of the User being passed as parameter\n    public ResponseEntity&lt;String&gt; isUserActive(User user){\n        return user.isActive() ? ResponseEntity.ok().build() : ResponseEntity.status(HttpStatus.NO_CONTENT).body(\"User not active\");\n    }\n\n    /*public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers(){\n        return ResponseEntity.ok(userRepository.findAll());\n    }*/\n\n    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers(){\n        List&lt;User&gt; users = userRepository.findAll();\n        return !users.isEmpty() ? ResponseEntity.ok(users) : ResponseEntity.notFound().build();\n    }\n\n    public ResponseEntity&lt;?&gt; getUserById(String id){\n        Optional&lt;User&gt; userById = userRepository.findById(id);\n        return userById.isPresent() ? ResponseEntity.ok(userById) : ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"User not found\");\n    }\n\n/*    public ResponseEntity&lt;?&gt; getUserById(String id) {\n        User user = userRepository.findById(id).orElse(null);\n        return Optional.ofNullable(user)\n                .map(ResponseEntity::ok)\n                .orElse(ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"User not found\"));\n    }*/\n\n\n/*    public ResponseEntity&lt;User&gt; getUserById(String id){\n        return userRepository.findById(id).map(ResponseEntity::ok).orElse(ResponseEntity.status(HttpStatus.NOT_FOUND).build());\n    }*/\n\n/*    public ResponseEntity&lt;User&gt; createUser(User user){\n        userRepository.save(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(user);\n    }*/\n\n    /*public ResponseEntity&lt;User&gt; updateUser(User user) {\n        return userRepository.findById(user.getId())\n                .map(existingUser -&gt; {\n                    userRepository.save(user);\n                    return ResponseEntity.ok(user);\n                })\n                .orElse(ResponseEntity.notFound().build());\n    }*/\n\n    public ResponseEntity&lt;User&gt; updateUser(User user){\n        if (userRepository.findById(user.getId()).isEmpty()){\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(user);\n        }\n        userRepository.save(user);\n        return ResponseEntity.status(HttpStatus.CREATED).body(user);\n    }\n\n    public ResponseEntity&lt;?&gt; createUser(User user){\n        Optional&lt;User&gt; user1 = Optional.of(userRepository.save(user));\n        return user1.isPresent() ? ResponseEntity.status(HttpStatus.CREATED).body(user1) : ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).body(\"Error saving\");\n    }\n\n    public void deleteAllWords(){\n        userRepository.deleteAll();\n    }\n\n    public ResponseEntity&lt;HttpStatus&gt; deleteById(String id){\n        userRepository.deleteById(id);\n        return userRepository.findById(id).isEmpty() ? ResponseEntity.status(HttpStatus.OK).build() : ResponseEntity.status(HttpStatus.NOT_FOUND).build();\n    }\n\n    public ResponseEntity&lt;HttpStatus&gt; deleteUser(User user){\n        userRepository.delete(user);\n        return userRepository.findById(user.getId()).isEmpty() ? ResponseEntity.status(HttpStatus.OK).build() : ResponseEntity.status(HttpStatus.NOT_FOUND).build();\n    }\n\n    public ResponseEntity&lt;Integer&gt; getUserLevel(User user){\n        if (userRepository.findById(user.getId()).isEmpty()){\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();\n        }\n        return ResponseEntity.status(HttpStatus.FOUND).body(user.getLevel());\n    }\n}\nCorrect usage of the Service layer\npackage dev.pronunciationAppBack.service;\n\nimport dev.pronunciationAppBack.model.User;\nimport dev.pronunciationAppBack.repository.UserRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public boolean isUserActive(User user) {\n        return user.isActive();\n    }\n\n    public List&lt;User&gt; getAllUsers() {\n        return userRepository.findAll();\n    }\n\n    public Optional&lt;User&gt; getUserById(String id) {\n        return userRepository.findById(id);\n    }\n\n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n\n    public Optional&lt;User&gt; updateUser(User user) {\n        return userRepository.findById(user.getId())\n                .map(existingUser -&gt; userRepository.save(user));\n    }\n\n    public void deleteAllUsers() {\n        userRepository.deleteAll();\n    }\n\n    public boolean deleteById(String id) {\n        if (userRepository.existsById(id)) {\n            userRepository.deleteById(id);\n            return true;\n        }\n        return false;\n    }\n\n    public boolean deleteUser(User user) {\n        if (userRepository.existsById(user.getId())) {\n            userRepository.delete(user);\n            return true;\n        }\n        return false;\n    }\n\n    public long getUserCount() {\n        return userRepository.count();\n    }\n\n    public Optional&lt;Integer&gt; getUserLevel(String userId) {\n        return userRepository.findById(userId).map(User::getLevel);\n    }\n}"
  }
]